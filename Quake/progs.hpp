/*
Copyright (C) 1996-2001 Id Software, Inc.
Copyright (C) 2002-2009 John Fitzgibbons and others
Copyright (C) 2010-2014 QuakeSpasm developers
Copyright (C) 2020-2020 Vittorio Romeo

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#pragma once

#include "pr_comp.hpp"  /* defs shared with qcc */
#include "progdefs.hpp" /* generated by program cdefs */
#include "common.hpp"
#include "sizebuf.hpp"
#include "protocol.hpp"

union eval_t
{
    string_t string;
    float _float;
    float vector[3];
    func_t function;
    int _int;
    int edict;
};

#define MAX_ENT_LEAFS 32

struct edict_t
{
    bool free;
    link_t area; /* linked to a division node or leaf */

    unsigned int num_leafs; // QSS
    int leafnums[MAX_ENT_LEAFS];

    entity_state_t baseline;
    unsigned char alpha; /* johnfitz -- hack to support alpha since it's not
                            part of entvars_t */
    bool sendinterval;   /* johnfitz -- send time until nextthink to client
                                for better lerp timing */
    bool onladder; /* spike -- content_ladder stuff */ // QSS

    float freetime; /* qcvm->time when the object was freed */
    entvars_t v;    /* C exported fields from progs */

    /* other fields from progs come immediately after */
};

#define EDICT_FROM_AREA(l) STRUCT_FROM_LINK(l, edict_t, area)

//============================================================================

extern dprograms_t* progs;
extern dfunction_t* pr_functions;
extern dstatement_t* pr_statements;
extern globalvars_t* pr_global_struct;
extern float* pr_globals; /* same as pr_global_struct */

extern int pr_edict_size; /* in bytes */


void PR_Init();

void PR_ExecuteProgram(func_t fnum);
void PR_LoadProgs();

const char* PR_GetString(int num);
int PR_SetEngineString(const char* s);
int PR_AllocString(int bufferlength, char** ptr);

void PR_Profile_f();

edict_t* ED_Alloc();
void ED_Free(edict_t* ed);

void ED_Print(edict_t* ed);
void ED_Write(FILE* f, edict_t* ed);
const char* ED_ParseEdict(const char* data, edict_t* ent);

void ED_WriteGlobals(FILE* f);
const char* ED_ParseGlobals(const char* data);

void ED_LoadFromFile(const char* data);

/*
#define EDICT_NUM(n)		((edict_t *)(qcvm->edicts+ (n)*pr_edict_size))
#define NUM_FOR_EDICT(e)	(((byte *)(e) - qcvm->edicts) / pr_edict_size)
*/
edict_t* EDICT_NUM(int n);
int NUM_FOR_EDICT(edict_t* e);

#define NEXT_EDICT(e) ((edict_t*)((byte*)e + pr_edict_size))

#define EDICT_TO_PROG(e) ((byte*)e - (byte*)qcvm->edicts)
#define PROG_TO_EDICT(e) ((edict_t*)((byte*)qcvm->edicts + e))

#define G_FLOAT(o) (qcvm->globals[o])
#define G_INT(o) (*(int*)&qcvm->globals[o])
#define G_EDICT(o) ((edict_t*)((byte*)qcvm->edicts + *(int*)&qcvm->globals[o]))
#define G_EDICTNUM(o) NUM_FOR_EDICT(G_EDICT(o))
#define G_VECTOR(o) (&qcvm->globals[o])
#define G_STRING(o) (PR_GetString(*(string_t*)&qcvm->globals[o]))
#define G_FUNCTION(o) (*(func_t*)&qcvm->globals[o])

#define E_FLOAT(e, o) (((float*)&e->v)[o])
#define E_INT(e, o) (*(int*)&((float*)&e->v)[o])
#define E_VECTOR(e, o) (&((float*)&e->v)[o])
#define E_STRING(e, o) (PR_GetString(*(string_t*)&((float*)&e->v)[o]))

extern int type_size[8];

typedef void (*builtin_t)();
extern builtin_t* pr_builtins;
extern const int pr_numbuiltins;

extern int pr_argc;

extern bool pr_trace;
extern dfunction_t* pr_xfunction;
extern int pr_xstatement;

extern unsigned short pr_crc;

[[noreturn]] void PR_RunError(const char* error, ...) FUNC_PRINTF(1, 2);
#ifdef __WATCOMC__
#pragma aux PR_RunError aborts;
#endif

void ED_PrintEdicts();
void ED_PrintNum(int ent);

eval_t* GetEdictFieldValue(edict_t* ed, const char* field);

// from pr_cmds, no longer static so that pr_ext can use them.
sizebuf_t* WriteDest();
char* PR_GetTempString();
int PR_MakeTempString(const char* val);
char* PF_VarString(int first);
#define STRINGTEMP_BUFFERS 1024
#define STRINGTEMP_LENGTH 1024
void PF_Fixme(); // the 'unimplemented' builtin. woot.

// TODO VR: (P0): QSS Merge - implement QCVM
template <typename T>
void PR_SwitchQCVM(T&& x)
{
    (void)x;
}

struct areanode_t;
struct qmodel_t;
struct edict_t;

template <typename T, std::size_t N>
using ref_to_array = T (&)[N];

struct fake_qcvm
{
    double& time;
    int& num_edicts;
    dprograms_t*& progs;
    int& edict_size;
    ref_to_array<areanode_t, 32> areanodes;
    int& numareanodes;
    int& max_edicts;
    qmodel_t*& worldmodel;
    edict_t*& edicts;
    float*& globals;
    int& argc;
    dfunction_t*& xfunction;
    bool& trace;

    typedef struct
    {
        int s;
        dfunction_t* f;
    } prstack_t;

#define MAX_STACK_DEPTH 64 /* was 32 */
    prstack_t stack[MAX_STACK_DEPTH];
    int depth;

#define LOCALSTACK_SIZE 2048
    int localstack[LOCALSTACK_SIZE];
    int localstack_used;

    int xstatement;

    dfunction_t*& functions;
    dstatement_t*& statements;

    builtin_t*& builtins;
    const int& numbuiltins;

    fake_qcvm(double& xtime, int& xnum_edicts, dprograms_t*& xprogs,
        int& xedict_size, ref_to_array<areanode_t, 32> xareanodes,
        int& xnumareanodes, int& xmax_edicts, qmodel_t*& xworldmodel,
        edict_t*& xedicts, float*& xglobals, int& xargc,
        dfunction_t*& xxfunction, bool& xtrace, dfunction_t*& xfunctions,
        dstatement_t*& xstatements, builtin_t*& xbuiltins, const int& xnumbuiltins)
        : time{xtime}, num_edicts{xnum_edicts}, progs{xprogs},
          edict_size{xedict_size}, areanodes{xareanodes},
          numareanodes{xnumareanodes}, max_edicts{xmax_edicts},
          worldmodel{xworldmodel}, edicts{xedicts}, globals{xglobals},
          argc{xargc}, xfunction{xxfunction}, trace{xtrace},
          functions{xfunctions}, statements{xstatements}, builtins{xbuiltins},
          numbuiltins{xnumbuiltins}
    {
    }
};

[[nodiscard]] fake_qcvm& getFakeQcvm() noexcept;

struct fake_qcvm_proxy
{
    [[nodiscard]] inline fake_qcvm& operator*() const noexcept
    {
        return getFakeQcvm();
    }

    [[nodiscard]] inline fake_qcvm* operator->() const noexcept
    {
        return &getFakeQcvm();
    }
};

extern fake_qcvm_proxy qcvm;
